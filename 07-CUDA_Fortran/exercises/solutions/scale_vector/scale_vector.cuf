module mathOps 
 contains

 attributes(global) subroutine scale_vector(alpha, a, c)
     implicit none

     real,intent(in)       :: a(:)
     real,intent(out)      :: c(:)

     real,intent(in),value :: alpha  ! pass the scalar argument by value

     integer               :: i, n

     n = size(a) 
     i = blockDim%x*(blockIdx%x-1) + threadIdx%x
     if (i <= n) c(i) = a(i)*alpha
    end subroutine scale_vector
end module mathOps


program main
    use mathOps
    use cudafor
    implicit none

    integer, parameter             :: N = 2048
    integer                        :: blockDim, gridDim
    real                           :: alpha = 2.0
    real,allocatable               :: a(:), c(:)
    real,allocatable,device        :: a_d(:), c_d(:)

    allocate(a(N), c(N), a_d(N), c_d(N)) ! Allocate host and device arrays


    a=1.0

    a_d = a ! Copy a into device


    blockDim = 256


    gridDim = ceiling(real(N)/blockDim)

    call scale_vector<<<gridDim,blockDim>>>(alpha,a_d,c_d) !Call the kernel



    c = c_d  !Copy results into host

    print*,"max_diff=", maxval(c-2.0) 

end program main